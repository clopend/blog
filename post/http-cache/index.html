<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><meta name=description content><title>HTTP 缓存</title><link rel=canonical href=https://blog.clopend.com/post/http-cache/><link rel=stylesheet href=https://blog.clopend.com/simple.min.css><link rel=stylesheet href=https://blog.clopend.com/styles.css></head><body><header><nav><a href=https://blog.clopend.com/>Home</a>
<a target=_blank href=https://github.com/clopend><svg class="icon" viewBox="0 0 32 32"><path d="M16 .395c-8.836.0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182.8.148 1.094-.347 1.094-.77.0-.381-.015-1.642-.022-2.979-4.452.968-5.391-1.888-5.391-1.888-.728-1.849-1.776-2.341-1.776-2.341-1.452-.993.11-.973.11-.973 1.606.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33.143-1.034.558-1.74 1.016-2.14-3.554-.404-7.29-1.777-7.29-7.907.0-1.747.625-3.174 1.649-4.295-.166-.403-.714-2.03.155-4.234.0.0 1.344-.43 4.401 1.64 1.276-.355 2.645-.532 4.005-.539 1.359.006 2.729.184 4.008.539 3.054-2.07 4.395-1.64 4.395-1.64.871 2.204.323 3.831.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295.0 6.145-3.743 7.498-7.306 7.895.574.497 1.085 1.47 1.085 2.963.0 2.141-.019 3.864-.019 4.391.0.426.288.925 1.099.768C27.421 29.457 32 23.462 32 16.395c0-8.837-7.164-16-16-16z"/></svg><span>Github</span></a></nav><h1>Clopend</h1><p>Less is More</p></header><main><h2>HTTP 缓存</h2><div>September 2021 · 1 minute read</div><div><h3 id=分类>分类</h3><ol><li>服务端缓存，又分为代理服务器缓存和反向代理服务器缓存</li><li>客户端缓存，即浏览器缓存</li></ol><h3 id=浏览器的缓存>浏览器的缓存</h3><p>Expires HTTP/1.0中的实现，返回的到期时间是服务器的时间，
这样一来如果浏览器和服务器时间相差特别大，缓存时间差别就很大，比如服务器和浏览器跨时区。
这是弊端，所以HTTP/1.1中采用了Cache-Control: max-age=number代替</p><p>Cache-Control 与Expires类似，都是指明当前资源的有效期，
告诉浏览器直接读缓存还是从服务器重新拉取。Cache-Control拥有比Expires更多的选择。
(如果同时存在Cache-Control与Expires，则Cache-Control优先级高)</p><p>以上二者都是强缓存，就是说若是命中缓存且缓存还有效就不发送请求，直接返回200(from cache)</p><p>Cache-Control的值可以是以下几种：</p><ul><li>public 可以被任何可缓存区缓存(包括代理服务器以及客户端)</li><li>private 单个用户的缓存，不可被共享，对于其他用户的请求无效，不允许代理服务器缓存</li><li>no-cache 请求或消息不能(或不使用？)缓存</li><li>no-store 完全不存</li><li>no-transform 代理不转换资源类型，例如image/jpg -> image/png</li><li>must-revalidate 和no-cache类似，暂时没弄明白</li><li>proxy-revalidate 代理缓存一旦过期则需向服务器请求</li><li>max-age 资源有效期，单位是秒</li></ul><h3 id=last-modifiedif-modified-since和etagif-none-match>Last-Modified/If-Modified-Since和Etag/If-None-Match</h3><p>这二者都要配合Cache-Control使用，当资源过期时(例如Cache-Control使用了max-age声明)，
若发现资源带有Last-Modified或Etag声明，则向服务器请求时带上If-Modified-Since或If-None-Match。
If-Modified-Since表示请求时间，服务器收到后与资源最后的修改时间做对比，
若发现这个请求时间比最后修改时间新，则说明资源自上次缓存后没有修改过，服务器直接返回304，
反之则需返回新的资源。而Etag则是服务器生成并且告知浏览器的当前资源在服务器的唯一标识，
If-None-Match标识Etag的值，服务器收到后可以进行比对，相同则返回304，不同则返回整个资源。</p><h3 id=用户行为与协商缓存>用户行为与协商缓存</h3><table><thead><tr><th>用户行为</th><th style=text-align:center>Expires/Cache-Control</th><th style=text-align:center>Last-Modified/Etag</th></tr></thead><tbody><tr><td>地址栏回车</td><td style=text-align:center>有效</td><td style=text-align:center>有效</td></tr><tr><td>页面链接跳转</td><td style=text-align:center>有效</td><td style=text-align:center>有效</td></tr><tr><td>新开窗口</td><td style=text-align:center>有效</td><td style=text-align:center>有效</td></tr><tr><td>前进、后退</td><td style=text-align:center>有效</td><td style=text-align:center>有效</td></tr><tr><td>F5刷新</td><td style=text-align:center>无效</td><td style=text-align:center>有效</td></tr><tr><td>Ctrl+F5刷新</td><td style=text-align:center>无效</td><td style=text-align:center>无效</td></tr></tbody></table><h3 id=参考>参考</h3><ol><li><a href=https://www.cnblogs.com/520yang/articles/4807408.html target=_blank>浏览器HTTP协议缓存机制详解</a></li><li><a href=http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html target=_blank>浏览器缓存机制</a></li></ol></div></main><footer><a class=next href=https://blog.clopend.com/post/oh-my-zsh/>Debian 安装 Oh-My-Zsh&nbsp;&#187;</a></footer></body></html>